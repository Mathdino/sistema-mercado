{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/outros/market-delivery-app/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\nimport { PrismaPg } from \"@prisma/adapter-pg\";\nimport { Pool } from \"pg\";\n\nconst prismaClientSingleton = () => {\n  const connectionString = process.env.DATABASE_URL || \"\";\n  const pool = new Pool({ connectionString });\n  const adapter = new PrismaPg(pool);\n  return new PrismaClient({ adapter });\n};\n\ndeclare global {\n  var prisma: undefined | ReturnType<typeof prismaClientSingleton>;\n}\n\nconst prisma = globalThis.prisma ?? prismaClientSingleton();\n\nexport default prisma;\n\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma = prisma;\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;;;;;;AAEA,MAAM,wBAAwB;IAC5B,MAAM,mBAAmB,QAAQ,GAAG,CAAC,YAAY,IAAI;IACrD,MAAM,OAAO,IAAI,4GAAI,CAAC;QAAE;IAAiB;IACzC,MAAM,UAAU,IAAI,+OAAQ,CAAC;IAC7B,OAAO,IAAI,6IAAY,CAAC;QAAE;IAAQ;AACpC;AAMA,MAAM,SAAS,WAAW,MAAM,IAAI;uCAErB;AAEf,wCAA2C,WAAW,MAAM,GAAG"}},
    {"offset": {"line": 99, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/outros/market-delivery-app/app/api/cleanup/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport prisma from \"@/lib/prisma\";\r\n// import { verifyJwt } from \"@/lib/jwt\"; // Temporarily disable auth for testing\r\n\r\nexport async function POST(req: NextRequest) {\r\n  try {\r\n    /*\r\n    // Temporarily disable auth for testing\r\n    // Get token from Authorization header or cookies\r\n    let token: string | null = null;\r\n    const authHeader = req.headers.get(\"authorization\");\r\n    \r\n    if (authHeader && authHeader.startsWith(\"Bearer \")) {\r\n      token = authHeader.substring(7);\r\n    } else {\r\n      // If not in header, try to get from cookies\r\n      const cookieHeader = req.headers.get(\"cookie\");\r\n      if (cookieHeader) {\r\n        // Split cookies by semicolon and trim whitespace\r\n        const cookies = cookieHeader.split(\";\").reduce((acc, cookie) => {\r\n          const [name, value] = cookie.trim().split(\"=\");\r\n          if (name && value) {\r\n            acc[name] = value;\r\n          }\r\n          return acc;\r\n        }, {} as Record<string, string>);\r\n        \r\n        token = cookies.token || null;\r\n      }\r\n    }\r\n    \r\n    if (!token) {\r\n      return NextResponse.json({ error: \"unauthorized\" }, { status: 401 });\r\n    }\r\n    \r\n    // Verify the JWT token\r\n    let decoded;\r\n    try {\r\n      decoded = await verifyJwt(token);\r\n    } catch {\r\n      return NextResponse.json({ error: \"invalid_token\" }, { status: 401 });\r\n    }\r\n    \r\n    // Check if user is admin\r\n    const user = await prisma.user.findUnique({\r\n      where: { id: decoded.sub },\r\n    });\r\n    \r\n    if (!user || user.role !== \"ADMIN\") {\r\n      return NextResponse.json({ error: \"forbidden\" }, { status: 403 });\r\n    }\r\n    */\r\n    \r\n    console.log(\"Starting order status cleanup...\");\r\n    \r\n    // First, let's see what statuses we have in the database using raw SQL\r\n    const statusResults: any[] = await prisma.$queryRaw`SELECT status, COUNT(*) as count FROM \"Order\" GROUP BY status`;\r\n    const statusCounts: Record<string, number> = {};\r\n    \r\n    statusResults.forEach(row => {\r\n      statusCounts[row.status] = parseInt(row.count);\r\n    });\r\n    \r\n    console.log(\"Current status distribution:\", statusCounts);\r\n    \r\n    // Update orders with old statuses to the new ones using raw SQL\r\n    console.log(\"Updating PREPARING orders to CONFIRMED...\");\r\n    const preparingUpdated = await prisma.$executeRaw`UPDATE \"Order\" SET status = 'CONFIRMED' WHERE status = 'PREPARING'`;\r\n    console.log(`Updated ${preparingUpdated} PREPARING orders`);\r\n    \r\n    console.log(\"Updating DELIVERING orders to CONFIRMED...\");\r\n    const deliveringUpdated = await prisma.$executeRaw`UPDATE \"Order\" SET status = 'CONFIRMED' WHERE status = 'DELIVERING'`;\r\n    console.log(`Updated ${deliveringUpdated} DELIVERING orders`);\r\n    \r\n    console.log(\"Updating DELIVERED orders to CONFIRMED...\");\r\n    const deliveredUpdated = await prisma.$executeRaw`UPDATE \"Order\" SET status = 'CONFIRMED' WHERE status = 'DELIVERED'`;\r\n    console.log(`Updated ${deliveredUpdated} DELIVERED orders`);\r\n    \r\n    console.log(\"Updating CANCELED orders to CANCELLED...\");\r\n    try {\r\n      const canceledUpdated = await prisma.$executeRaw`UPDATE \"Order\" SET status = 'CANCELLED' WHERE status = 'CANCELED'`;\r\n      console.log(`Updated ${canceledUpdated} CANCELED orders`);\r\n    } catch (error: any) {\r\n      console.log(\"No CANCELED orders found or error updating them:\", error.message);\r\n    }\r\n    \r\n    console.log(\"Cleanup completed successfully!\");\r\n    \r\n    // Check final status distribution\r\n    const finalStatusResults: any[] = await prisma.$queryRaw`SELECT status, COUNT(*) as count FROM \"Order\" GROUP BY status`;\r\n    const finalStatusCounts: Record<string, number> = {};\r\n    \r\n    finalStatusResults.forEach(row => {\r\n      finalStatusCounts[row.status] = parseInt(row.count);\r\n    });\r\n    \r\n    console.log(\"Final status distribution:\", finalStatusCounts);\r\n    \r\n    return NextResponse.json({ \r\n      message: \"Cleanup completed successfully!\",\r\n      initialStats: statusCounts,\r\n      finalStats: finalStatusCounts\r\n    });\r\n  } catch (error: any) {\r\n    console.error(\"Error during cleanup:\", error);\r\n    return NextResponse.json({ error: \"internal_server_error\", details: error.message }, { status: 500 });\r\n  }\r\n}"],"names":[],"mappings":";;;;AAAA;AACA;;;;;;;AAGO,eAAe,KAAK,GAAgB;IACzC,IAAI;QACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA6CA,GAEA,QAAQ,GAAG,CAAC;QAEZ,uEAAuE;QACvE,MAAM,gBAAuB,MAAM,0HAAM,CAAC,SAAS,CAAC,6DAA6D,CAAC;QAClH,MAAM,eAAuC,CAAC;QAE9C,cAAc,OAAO,CAAC,CAAA;YACpB,YAAY,CAAC,IAAI,MAAM,CAAC,GAAG,SAAS,IAAI,KAAK;QAC/C;QAEA,QAAQ,GAAG,CAAC,gCAAgC;QAE5C,gEAAgE;QAChE,QAAQ,GAAG,CAAC;QACZ,MAAM,mBAAmB,MAAM,0HAAM,CAAC,WAAW,CAAC,kEAAkE,CAAC;QACrH,QAAQ,GAAG,CAAC,CAAC,QAAQ,EAAE,iBAAiB,iBAAiB,CAAC;QAE1D,QAAQ,GAAG,CAAC;QACZ,MAAM,oBAAoB,MAAM,0HAAM,CAAC,WAAW,CAAC,mEAAmE,CAAC;QACvH,QAAQ,GAAG,CAAC,CAAC,QAAQ,EAAE,kBAAkB,kBAAkB,CAAC;QAE5D,QAAQ,GAAG,CAAC;QACZ,MAAM,mBAAmB,MAAM,0HAAM,CAAC,WAAW,CAAC,kEAAkE,CAAC;QACrH,QAAQ,GAAG,CAAC,CAAC,QAAQ,EAAE,iBAAiB,iBAAiB,CAAC;QAE1D,QAAQ,GAAG,CAAC;QACZ,IAAI;YACF,MAAM,kBAAkB,MAAM,0HAAM,CAAC,WAAW,CAAC,iEAAiE,CAAC;YACnH,QAAQ,GAAG,CAAC,CAAC,QAAQ,EAAE,gBAAgB,gBAAgB,CAAC;QAC1D,EAAE,OAAO,OAAY;YACnB,QAAQ,GAAG,CAAC,oDAAoD,MAAM,OAAO;QAC/E;QAEA,QAAQ,GAAG,CAAC;QAEZ,kCAAkC;QAClC,MAAM,qBAA4B,MAAM,0HAAM,CAAC,SAAS,CAAC,6DAA6D,CAAC;QACvH,MAAM,oBAA4C,CAAC;QAEnD,mBAAmB,OAAO,CAAC,CAAA;YACzB,iBAAiB,CAAC,IAAI,MAAM,CAAC,GAAG,SAAS,IAAI,KAAK;QACpD;QAEA,QAAQ,GAAG,CAAC,8BAA8B;QAE1C,OAAO,+QAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,cAAc;YACd,YAAY;QACd;IACF,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,yBAAyB;QACvC,OAAO,+QAAY,CAAC,IAAI,CAAC;YAAE,OAAO;YAAyB,SAAS,MAAM,OAAO;QAAC,GAAG;YAAE,QAAQ;QAAI;IACrG;AACF"}}]
}